Assignment 0 [100 Points]
This assignment is a refresher for multi-threaded programming using pthreads. You have one problem in this assignment and you are provided the source code (with a driver program for executing the solution), the test script, and the expected output to be generated by your solution. You are expected to fill the various functions (explained in detail below) in order to complete the assignment. You can find a tutorial for pthreads here for a quick review.

Before starting this assignment, you should have completed Tutorial 1 which walks you through how to use our servers for your code development.

General Instructions
You are provided with the source code here. The compiler used is g++ 7.5.0 and is already installed in the servers. To run the program, follow the steps below:
Run make producer_consumer. This creates a binary file called producer_consumer.
Create a slurm job to run the binary file using the following command: ./producer_consumer --nItems 100000 --nProducers 2 --nConsumers 4 --bufferSize 100000
--nProducers and --nConsumers are used to specify the number of producer and consumer threads. So, the above command will create 6 threads. (Detailed description about the various arguments for producer_consumer can be found below.)
While testing your solutions, make sure that cpus-per-task is correctly specified in your slurm config file based on your requirement.
You will be asked to print the time spent by different threads on specific code regions. The time spent by any code region can be computed as follows:
timer t1;
t1.start();
/* ---- Code region whose time is to be measured --- */
double time_taken = t1.stop();˚
Sample outputs for all the programs can be found in sample_outputs directory. Programs will be evaluated and graded automatically. Please make sure that your program output strictly follows the sample output format.
We have provided test scripts for you to quickly test your solutions during your development process. You can test your code using the test script, /scratch/assignment0/test_scripts/solution_tester.pyc. Note that these test scripts only validate the output formats, and a different evaluation script will be used for grading the assignments. Important: You should use slurm when performing these and other tests. This test script may use up to 8 threads; make sure --cpus-per-task=8 is set in your slurm job.
We have compiled a list of common mistakes and poor parallel programming practices that should be avoided. You are expected to understand them and avoid such mistakes.
1. Producer-Consumer Problem [100 Points]
In this problem, we want to create p producer threads each producing n items (the items are 0, 1, 2, ..., n-1), and q consumer threads consuming those items. The produced items are enqueued in a buffer queue called production_buffer (the implementation for the queue is available in core/circular_queue.h), and are dequeued for consumption. Both producer and consumer threads operate concurrently. Since multiple producer threads enqueue the items and multiple consumer threads dequeue the items from the same queue, you should use mutex when accessing the queue (critical section).

In addition, care must be taken to carefully handle when the production_buffer is full or empty to avoid overflow (items cannot be produced when queue is full) and underflow (items cannot be consumed when queue is empty). Each producer should correctly produce n items and the total number of items consumed by all the consumers should be equal to the total number of items produced. You are expected to use conditional variables as required to ensure correctness and to prevent any deadlocks or infinite waiting.

In order to evaluate correctness, we also compute the value of items produced/consumed by each thread. For producers, the value produced is the sum of all the items produced (and enqueued) and for consumers, the value consumed is the sum of all the items consumed.

The logic for both the producer and consumer threads is shown below. Make sure your solution retains the long datatype for variables, as shown below:

Producer threads:

    producerFunction() {
        // Each producer enqueues `n` items
        long item = 0;
        long items_produced = 0;
        long value_produced = 0;  
        while(items_produced < n) {
            bool ret = production_buffer.enqueue(item);
            if(ret == true) {
                if(production_buffer.itemCount() == 1){
                    // The queue is no longer empty
                    // Signal all consumers indicating queue is not empty
                }
                value_produced += item;
                items_produced++;
                item++;
            }
            else {
                // production_buffer is full, so block on conditional variable waiting for consumer to signal.
            }
        }

        // After production is completed:
        // Update the number of producers that are currently active.
        --active_producer_count;
        // The producer that was last active (can be determined using `active_producer_count`) will keep signalling the consumers until all consumers have finished (can be determined using `active_consumer_count`).
    }
Consumer threads:

    consumerFunction(){
        // Each consumer dequeues items from the `production_buffer` 
        long item;
        long items_consumed = 0;
        long value_consumed = 0;  
        while(true) {
            bool ret = production_buffer.dequeue(&item);
            if(ret == true) {
                if(production_buffer.itemCount() == production_buffer.getCapacity() - 1){
                    // The queue is no longer full
                    // Signal all producers indicating queue is not full
                }
                value_consumed += item;
                items_consumed++;
            }
            else {
                // production_buffer is empty, so block on conditional variable waiting for producer to signal.
                // The thread can wake up because of 2 scenarios:
                // Scenario 1: There are no more active producers (i.e., production is complete) and the queue is empty. This is the exit condition for consumers, and at this point consumers should decrement `active_consumer_count`. 
                // Scenario 2: The queue is not empty and/or the producers are active. Continue consuming.
            }
        }
    }
In addition, you are provided the following methods for the ProducerConsumerProblem class in solution.cpp file.

ProducerConsumerProblem() and ~ProducerConsumerProblem() - Constructor and destructor for the ProducerConsumerProblem class. You can initialize/destroy your mutexes and conditional variables here.
startProducers() and startConsumers() - Methods where producer and consumer threads should be created respectively (use pthread_create() here).
joinProducers() and joinConsumers() - Methods where producer and consumer threads should be joined with the main thread.
printStats() - Method to print statistics of the producer and consumer threads (see output requirements below).
NOTE: You should not change the signature (i.e., function names, parameters, return types) of these 7 methods. To evaluate your solutions, we will use different driver programs that will rely on the provided function signatures. You can define additional structs, classes or functions in solution.cpp or solution.h as necessary.

The driver program (in driver.cpp) processes the following command-line parameters, and calls various methods of the ProducerConsumerProblem class.

--nItems: the number of items produced by each producer.
--nProducers: the number of producer threads.
--nConsumers: the number of consumer threads.
--bufferSize: the size of the buffer used for production_buffer.
Your solution must satisfy the following:

The executable should support the 4 command-line parameters mentioned above. This is already taken care by driver.cpp and make sure your solution is not dependant on any other command-line parameters since the driver program used for evaluation may not be the same.
Output the following (sample output can be found in sample_outputs/producer_consumer.output file):
The total number of producer and consumer threads.
For each producer thread: the producer id, the number of items produced by the producer, the total value of the items produced, the time taken by the producer thread (i.e. time between the start and end of the producer function).
For each consumer thread: the consumer id, the number of items consumed by the consumer, the total value of the items consumed, the time taken by the consumer thread (i.e. time between the start and end of the consumer function).
The total number of items consumed by all consumers.
The total time taken (this is already printed by the driver program).
Please note that the output format should strictly match the expected format (including "spaces" and "commas"). You can test your code using the test script as follows (remember to run this via slurm):

    $ python /scratch/assignment0/test_scripts/solution_tester.pyc --execPath=<absolute path of producer_consumer executable file>
Submission Guidelines
Make sure that your solutions folder has the following files and sub-folders. Let's say your solutions folder is called my_assignment0_solutions. It should contain:

core/ -- The folder containing all core files. It is already available in the assignement package. Do not modify it or remove any files.
Makefile -- Makefile for the project. This file should not be changed.
driver.cpp
solution.cpp
solution.h
To create the submission file, follow the steps below:

Enter in your solutions folder, and remove all the object/temporary files.
$ cd my_assignment0_solutions/
$ make clean
Create the tar.gz file.
$ tar cvzf assignment0.tar.gz *
which creates a compressed tar ball that contains the contents of the folder.
Validate the tar ball using the submission_validator.pyc script.
$ python /scratch/assignment0/test_scripts/submission_validator.pyc --tarPath=assignment0.tar.gz
Submit via CourSys by the deadline posted there.

Copyright © 2023 Keval Vora. All rights reserved.